diff --git a/AUTHORS b/AUTHORS
index 0acaa9e..79bbb8f 100644
--- a/AUTHORS
+++ b/AUTHORS
@@ -8,6 +8,7 @@
 #
 # Please keep the list sorted.
 
+Delilah Hoare <delilah@dhoare.me>
 Google Inc.
 Koichi Shiraishi <zchee.io@gmail.com>
 Kouhei Sutou <kou@cozmixng.org>
diff --git a/CONTRIBUTORS b/CONTRIBUTORS
index 3c2e7d4..3d447d5 100644
--- a/CONTRIBUTORS
+++ b/CONTRIBUTORS
@@ -24,6 +24,7 @@
 
 Colin Cross <ccross@google.com>
 Dan Willemsen <dwillemsen@google.com>
+Delilah Hoare <delilah@dhoare.me>
 Fumitoshi Ukai <ukai@google.com>
 Koichi Shiraishi <zchee.io@gmail.com>
 Kouhei Sutou <kou@cozmixng.org>
diff --git a/src/command.cc b/src/command.cc
index 5268b9e..027a975 100644
--- a/src/command.cc
+++ b/src/command.cc
@@ -21,6 +21,7 @@
 
 #include "dep.h"
 #include "eval.h"
+#include "fileutil.h"
 #include "flags.h"
 #include "log.h"
 #include "strutil.h"
@@ -52,6 +53,13 @@ class AutoVar : public Var {
 
   CommandEvaluator* ce_;
   const char* sym_;
+
+  const DepNode* CurrentDepNode(Evaluator* ev) const {
+    if (ev->current_dep_node != nullptr) {
+      return ev->current_dep_node;
+    }
+    return ce_->current_dep_node();
+  }
 };
 
 #define DECLARE_AUTO_VAR_CLASS(name)                                  \
@@ -66,7 +74,9 @@ DECLARE_AUTO_VAR_CLASS(AutoAtVar);
 DECLARE_AUTO_VAR_CLASS(AutoLessVar);
 DECLARE_AUTO_VAR_CLASS(AutoHatVar);
 DECLARE_AUTO_VAR_CLASS(AutoPlusVar);
+DECLARE_AUTO_VAR_CLASS(AutoPipeVar);
 DECLARE_AUTO_VAR_CLASS(AutoStarVar);
+DECLARE_AUTO_VAR_CLASS(AutoQuestionVar);
 DECLARE_AUTO_VAR_CLASS(AutoNotImplementedVar);
 
 class AutoSuffixDVar : public AutoVar {
@@ -91,40 +101,83 @@ class AutoSuffixFVar : public AutoVar {
   Var* wrapped_;
 };
 
-void AutoAtVar::Eval(Evaluator*, string* s) const {
-  *s += ce_->current_dep_node()->output.str();
+void AutoAtVar::Eval(Evaluator* ev, string* s) const {
+  *s += CurrentDepNode(ev)->output.str();
 }
 
-void AutoLessVar::Eval(Evaluator*, string* s) const {
-  auto& ai = ce_->current_dep_node()->actual_inputs;
+void AutoLessVar::Eval(Evaluator* ev, string* s) const {
+  auto& ai = CurrentDepNode(ev)->actual_inputs;
   if (!ai.empty())
     *s += ai[0].str();
 }
 
-void AutoHatVar::Eval(Evaluator*, string* s) const {
+void AutoHatVar::Eval(Evaluator* ev, string* s) const {
   unordered_set<StringPiece> seen;
   WordWriter ww(s);
-  for (Symbol ai : ce_->current_dep_node()->actual_inputs) {
+  for (Symbol ai : CurrentDepNode(ev)->actual_inputs) {
     if (seen.insert(ai.str()).second)
       ww.Write(ai.str());
   }
 }
 
-void AutoPlusVar::Eval(Evaluator*, string* s) const {
+void AutoPlusVar::Eval(Evaluator* ev, string* s) const {
   WordWriter ww(s);
-  for (Symbol ai : ce_->current_dep_node()->actual_inputs) {
+  for (Symbol ai : CurrentDepNode(ev)->actual_inputs) {
     ww.Write(ai.str());
   }
 }
 
-void AutoStarVar::Eval(Evaluator*, string* s) const {
-  const DepNode* n = ce_->current_dep_node();
+void AutoPipeVar::Eval(Evaluator*, string* s) const {
+  WordWriter ww(s);
+  for (Symbol ai : ce_->current_dep_node()->actual_order_only_inputs) {
+    ww.Write(ai.str());
+  }
+}
+
+void AutoStarVar::Eval(Evaluator* ev, string* s) const {
+  const DepNode* n = CurrentDepNode(ev);
   if (!n->output_pattern.IsValid())
     return;
   Pattern pat(n->output_pattern.str());
   pat.Stem(n->output.str()).AppendToString(s);
 }
 
+void AutoQuestionVar::Eval(Evaluator* ev, string* s) const {
+  unordered_set<StringPiece> seen;
+
+  if (ev->avoid_io()) {
+    // Check timestamps using the shell at the start of rule execution
+    // instead.
+    *s += "${KATI_NEW_INPUTS}";
+    if (!ce_->found_new_inputs()) {
+      string def;
+
+      WordWriter ww(&def);
+      ww.Write("KATI_NEW_INPUTS=$(find");
+      for (Symbol ai : CurrentDepNode(ev)->actual_inputs) {
+        if (seen.insert(ai.str()).second) {
+          ww.Write(ai.str());
+        }
+      }
+      ww.Write("$(test -e");
+      ww.Write(CurrentDepNode(ev)->output.str());
+      ww.Write("&& echo -newer");
+      ww.Write(CurrentDepNode(ev)->output.str());
+      ww.Write(")) && export KATI_NEW_INPUTS");
+      ev->add_delayed_output_command(def);
+      ce_->set_found_new_inputs(true);
+    }
+  } else {
+    WordWriter ww(s);
+    double target_age = GetTimestamp(CurrentDepNode(ev)->output.str());
+    for (Symbol ai : CurrentDepNode(ev)->actual_inputs) {
+      if (seen.insert(ai.str()).second && GetTimestamp(ai.str()) > target_age) {
+        ww.Write(ai.str());
+      }
+    }
+  }
+}
+
 void AutoNotImplementedVar::Eval(Evaluator* ev, string*) const {
   ev->Error(StringPrintf("Automatic variable `$%s' isn't supported yet", sym_));
 }
@@ -178,11 +231,11 @@ CommandEvaluator::CommandEvaluator(Evaluator* ev) : ev_(ev) {
   INSERT_AUTO_VAR(AutoLessVar, "<");
   INSERT_AUTO_VAR(AutoHatVar, "^");
   INSERT_AUTO_VAR(AutoPlusVar, "+");
+  INSERT_AUTO_VAR(AutoPipeVar, "|");
   INSERT_AUTO_VAR(AutoStarVar, "*");
+  INSERT_AUTO_VAR(AutoQuestionVar, "?");
   // TODO: Implement them.
   INSERT_AUTO_VAR(AutoNotImplementedVar, "%");
-  INSERT_AUTO_VAR(AutoNotImplementedVar, "?");
-  INSERT_AUTO_VAR(AutoNotImplementedVar, "|");
 }
 
 std::vector<Command> CommandEvaluator::Eval(const DepNode& n) {
@@ -191,6 +244,7 @@ std::vector<Command> CommandEvaluator::Eval(const DepNode& n) {
   ev_->set_current_scope(n.rule_vars);
   ev_->SetEvaluatingCommand(true);
   current_dep_node_ = &n;
+  found_new_inputs_ = false;
   for (Value* v : n.cmds) {
     ev_->set_loc(v->Location());
     const string&& cmds_buf = v->Eval(ev_);
@@ -231,6 +285,7 @@ std::vector<Command> CommandEvaluator::Eval(const DepNode& n) {
       c.cmd = cmd;
       c.echo = false;
       c.ignore_error = false;
+      c.force_no_subshell = true;
     }
     // Prepend |output_commands|.
     result.swap(output_commands);
diff --git a/src/command.h b/src/command.h
index 017f6bb..fb1ade3 100644
--- a/src/command.h
+++ b/src/command.h
@@ -25,11 +25,13 @@ struct DepNode;
 class Evaluator;
 
 struct Command {
-  explicit Command(Symbol o) : output(o), echo(true), ignore_error(false) {}
+  explicit Command(Symbol o)
+      : output(o), echo(true), ignore_error(false), force_no_subshell(false) {}
   Symbol output;
   string cmd;
   bool echo;
   bool ignore_error;
+  bool force_no_subshell;
 };
 
 class CommandEvaluator {
@@ -38,10 +40,13 @@ class CommandEvaluator {
   std::vector<Command> Eval(const DepNode& n);
   const DepNode* current_dep_node() const { return current_dep_node_; }
   Evaluator* evaluator() const { return ev_; }
+  bool found_new_inputs() const { return found_new_inputs_; }
+  void set_found_new_inputs(bool val) { found_new_inputs_ = val; }
 
  private:
   Evaluator* ev_;
   const DepNode* current_dep_node_;
+  bool found_new_inputs_;
 };
 
 #endif  // COMMAND_H_
diff --git a/src/dep.cc b/src/dep.cc
index bf4c947..57e44a5 100644
--- a/src/dep.cc
+++ b/src/dep.cc
@@ -212,17 +212,22 @@ struct RuleMerger {
     rules.push_back(r);
   }
 
-  void FillDepNodeFromRule(Symbol output, const Rule* r, DepNode* n) const {
+  void FillDepNodeFromRule(Symbol output, const Rule* rule_unparsed, DepNode* n, Evaluator* ev) const {
+    Rule r(*rule_unparsed);
+    ev->current_dep_node = n;
+    r.ParseInputs(ev);
+    ev->current_dep_node = nullptr;
+
     if (is_double_colon)
-      copy(r->cmds.begin(), r->cmds.end(), back_inserter(n->cmds));
+      copy(r.cmds.begin(), r.cmds.end(), back_inserter(n->cmds));
 
-    ApplyOutputPattern(*r, output, r->inputs, &n->actual_inputs);
-    ApplyOutputPattern(*r, output, r->order_only_inputs,
+    ApplyOutputPattern(r, output, r.inputs, &n->actual_inputs);
+    ApplyOutputPattern(r, output, r.order_only_inputs,
                        &n->actual_order_only_inputs);
 
-    if (r->output_patterns.size() >= 1) {
-      CHECK(r->output_patterns.size() == 1);
-      n->output_pattern = r->output_patterns[0];
+    if (r.output_patterns.size() >= 1) {
+      CHECK(r.output_patterns.size() == 1);
+      n->output_pattern = r.output_patterns[0];
     }
   }
 
@@ -232,14 +237,14 @@ struct RuleMerger {
       n->loc.lineno = r->cmd_lineno;
   }
 
-  void FillDepNode(Symbol output, const Rule* pattern_rule, DepNode* n) const {
+  void FillDepNode(Symbol output, const Rule* pattern_rule, DepNode* n, Evaluator* ev) const {
     if (primary_rule) {
       CHECK(!pattern_rule);
-      FillDepNodeFromRule(output, primary_rule, n);
+      FillDepNodeFromRule(output, primary_rule, n, ev);
       FillDepNodeLoc(primary_rule, n);
       n->cmds = primary_rule->cmds;
     } else if (pattern_rule) {
-      FillDepNodeFromRule(output, pattern_rule, n);
+      FillDepNodeFromRule(output, pattern_rule, n, ev);
       FillDepNodeLoc(pattern_rule, n);
       n->cmds = pattern_rule->cmds;
     }
@@ -247,7 +252,7 @@ struct RuleMerger {
     for (const Rule* r : rules) {
       if (r == primary_rule)
         continue;
-      FillDepNodeFromRule(output, r, n);
+      FillDepNodeFromRule(output, r, n, ev);
       if (n->loc.filename == NULL)
         n->loc = r->loc;
     }
@@ -259,7 +264,7 @@ struct RuleMerger {
       n->implicit_outputs.push_back(implicit_output.first);
       all_outputs.insert(implicit_output.first);
       for (const Rule* r : implicit_output.second->rules) {
-        FillDepNodeFromRule(output, r, n);
+        FillDepNodeFromRule(output, r, n, ev);
       }
     }
 
@@ -338,7 +343,6 @@ class DepBuilder {
                                                        ".PRECIOUS",
                                                        ".INTERMEDIATE",
                                                        ".SECONDARY",
-                                                       ".SECONDEXPANSION",
                                                        ".IGNORE",
                                                        ".LOW_RESOLUTION_TIME",
                                                        ".SILENT",
@@ -357,7 +361,7 @@ class DepBuilder {
 
   void Build(vector<Symbol> targets, vector<NamedDepNode>* nodes) {
     if (!first_rule_.IsValid()) {
-      ERROR("*** No targets.");
+      //ERROR("*** No targets.");
     }
 
     if (!g_flags.gen_all_targets && targets.empty()) {
@@ -398,8 +402,11 @@ class DepBuilder {
 
  private:
   bool Exists(Symbol target) {
-    return (rules_.find(target) != rules_.end()) || phony_.exists(target) ||
-           ::Exists(target.str());
+    if ((rules_.find(target) != rules_.end()) || phony_.exists(target) ||
+           ::Exists(target.str())) {
+             return true;
+    }
+    return BuildPlan(target, Intern("(Exists)"))->has_rule; // fixme
   }
 
   bool GetRuleInputs(Symbol s, vector<Symbol>* o, Loc* l) {
@@ -410,8 +417,10 @@ class DepBuilder {
     o->clear();
     CHECK(!found->second.rules.empty());
     *l = found->second.rules.front()->loc;
-    for (const Rule* r : found->second.rules) {
-      for (Symbol i : r->inputs)
+    for (const Rule* rule_unparsed : found->second.rules) {
+      Rule r(*rule_unparsed);
+      r.ParseInputs(ev_);
+      for (Symbol i : r.inputs)
         o->push_back(i);
     }
     return true;
@@ -553,18 +562,34 @@ class DepBuilder {
                            DepNode* n,
                            shared_ptr<Rule>* out_rule) {
     Symbol matched;
+    shared_ptr<Rule> applied;
     for (Symbol output_pattern : rule->output_patterns) {
       Pattern pat(output_pattern.str());
       if (pat.Match(output.str())) {
+        if (rule_stack_.size() != 0 && rule_stack_.back() == rule) {
+          // TODO: This is probably not correct.
+          // It's basically a hack to get around the linux kernel
+          // rule like `%: %_shipped`, which would keep trying to
+          // make the `%_shipped` file with itself, so
+          // `%_shipped_shipped` and so on.  So this prevents any
+          // pattern rule from being able to make a direct input with
+          // itself.
+          // I don't know how gnu make handles this situation.
+          continue;
+        }
+        rule_stack_.push_back(rule);
+        applied = rule->ApplyPattern(pat, output);
+        ev_->current_dep_node = n;
+        applied->ParseInputs(ev_);
+        ev_->current_dep_node = nullptr;
         bool ok = true;
-        for (Symbol input : rule->inputs) {
-          string buf;
-          pat.AppendSubst(output.str(), input.str(), &buf);
-          if (!Exists(Intern(buf))) {
+        for (Symbol input : applied->inputs) {
+          if (!Exists(input)) {
             ok = false;
             break;
           }
         }
+        rule_stack_.pop_back();
 
         if (ok) {
           matched = output_pattern;
@@ -575,7 +600,7 @@ class DepBuilder {
     if (!matched.IsValid())
       return false;
 
-    *out_rule = make_shared<Rule>(*rule);
+    *out_rule = applied;
     if ((*out_rule)->output_patterns.size() > 1) {
       // We should mark all other output patterns as used.
       Pattern pat(matched.str());
@@ -698,9 +723,9 @@ class DepBuilder {
     }
 
     if (rule_merger)
-      rule_merger->FillDepNode(output, pattern_rule.get(), n);
+      rule_merger->FillDepNode(output, pattern_rule.get(), n, ev_);
     else
-      RuleMerger().FillDepNode(output, pattern_rule.get(), n);
+      RuleMerger().FillDepNode(output, pattern_rule.get(), n, ev_);
 
     vector<unique_ptr<ScopedVar>> sv;
     ScopedFrame frame(ev_->Enter(FrameType::DEPENDENCY, output.str(), n->loc));
@@ -940,6 +965,8 @@ class DepBuilder {
   Symbol symlink_outputs_var_name_;
   Symbol ninja_pool_var_name_;
   Symbol validations_var_name_;
+
+  vector<const Rule*> rule_stack_;
 };
 
 void MakeDep(Evaluator* ev,
diff --git a/src/eval.cc b/src/eval.cc
index 7f9dc6f..321db5d 100644
--- a/src/eval.cc
+++ b/src/eval.cc
@@ -159,7 +159,8 @@ Evaluator::Evaluator()
       eval_depth_(0),
       posix_sym_(Intern(".POSIX")),
       is_posix_(false),
-      export_error_(false) {
+      export_error_(false),
+      makefiles_({Intern(g_flags.makefile)}) {
 #if defined(__APPLE__)
   stack_size_ = pthread_get_stacksize_np(pthread_self());
   stack_addr_ = (char*)pthread_get_stackaddr_np(pthread_self()) - stack_size_;
@@ -235,6 +236,12 @@ void Evaluator::in_toplevel_makefile() {
   is_commandline_ = false;
 }
 
+void Evaluator::ExportEnvVars(const vector<Symbol>& envvars) {
+  for (Symbol var : envvars) {
+    exports_[var] = true;
+  }
+}
+
 Var* Evaluator::EvalRHS(Symbol lhs,
                         Value* rhs_v,
                         StringPiece orig_rhs,
@@ -474,6 +481,12 @@ void Evaluator::EvalRule(const RuleStmt* stmt) {
   bool is_pattern_rule;
   StringPiece after_targets =
       ParseRuleTargets(loc_, before_term, &targets, &is_pattern_rule);
+  for (const auto& t : targets) {
+    if (t.str() == ".SECONDEXPANSION") {
+      second_expansion_ = true;
+      break;
+    }
+  }
   bool is_double_colon = (after_targets[0] == ':');
   if (is_double_colon) {
     after_targets = after_targets.substr(1);
@@ -510,6 +523,7 @@ void Evaluator::EvalRule(const RuleStmt* stmt) {
   Rule* rule = new Rule();
   rule->loc = loc_;
   rule->is_double_colon = is_double_colon;
+  rule->second_expansion = second_expansion_;
   if (is_pattern_rule) {
     rule->output_patterns.swap(targets);
   } else {
@@ -605,25 +619,28 @@ void Evaluator::EvalIf(const IfStmt* stmt) {
   }
 }
 
-void Evaluator::DoInclude(const string& fname) {
+void Evaluator::DoInclude(const string& fname, bool should_exist) {
   CheckStack();
   COLLECT_STATS_WITH_SLOW_REPORT("included makefiles", fname.c_str());
 
   const Makefile& mk = MakefileCacheManager::Get().ReadMakefile(fname);
-  if (!mk.Exists()) {
-    Error(StringPrintf("%s does not exist", fname.c_str()));
-  }
+
+  Symbol fsym = Intern(TrimLeadingCurdir(fname));
+  (should_exist ? makefiles_ : optional_makefiles_).push_back(fsym);
 
   Var* var_list = LookupVar(Intern("MAKEFILE_LIST"));
   var_list->AppendVar(
-      this, Value::NewLiteral(Intern(TrimLeadingCurdir(fname)).str()));
-  for (Stmt* stmt : mk.stmts()) {
-    LOG("%s", stmt->DebugString().c_str());
-    stmt->Eval(this);
-  }
+      this, Value::NewLiteral(fsym.str()));
+
+  if (mk.Exists()) {
+    for (Stmt* stmt : mk.stmts()) {
+      LOG("%s", stmt->DebugString().c_str());
+      stmt->Eval(this);
+    }
 
-  for (auto& mk : profiled_files_) {
-    stats.MarkInteresting(mk);
+    for (auto& mk : profiled_files_) {
+      stats.MarkInteresting(mk);
+    }
   }
   profiled_files_.clear();
 }
@@ -635,15 +652,23 @@ void Evaluator::EvalInclude(const IncludeStmt* stmt) {
   const string&& pats = stmt->expr->Eval(this);
   for (StringPiece pat : WordScanner(pats)) {
     ScopedTerminator st(pat);
-    const auto& files = Glob(pat.data());
-
-    if (stmt->should_exist) {
-      if (files.empty()) {
-        // TODO: Kati does not support building a missing include file.
-        Error(StringPrintf("%s: %s", pat.data(), strerror(errno)));
+    auto files = Glob(pat.data());
+    
+    if (files->size() == 0) {
+      for (auto inc_path : g_flags.include_dirs) {
+        auto to_check = (inc_path + '/' + pat.data());
+        LOG("searching for %s in : %s", pat.data(), inc_path.c_str());
+        Glob(to_check.c_str(), &files);
+        if (files->size() > 0)
+          break;
       }
     }
 
+    if (files.empty()) {
+      // Glob matched no files so use it as a literal name.
+      files.push_back(pat.data());
+    }
+
     include_stack_.push_back(stmt->loc());
 
     for (const string& fname : files) {
@@ -654,7 +679,7 @@ void Evaluator::EvalInclude(const IncludeStmt* stmt) {
 
       {
         ScopedFrame frame(Enter(FrameType::PARSE, fname, stmt->loc()));
-        DoInclude(fname);
+        DoInclude(fname, stmt->should_exist);
       }
     }
     include_stack_.pop_back();
diff --git a/src/eval.h b/src/eval.h
index 75038ef..9ed7963 100644
--- a/src/eval.h
+++ b/src/eval.h
@@ -29,6 +29,7 @@
 
 using namespace std;
 
+struct DepNode;
 class Makefile;
 class Rule;
 class Var;
@@ -128,6 +129,8 @@ class Evaluator {
   bool Start();
   void Finish();
 
+  void ExportEnvVars(const vector<Symbol>& envvars);
+
   void EvalAssign(const AssignStmt* stmt);
   void EvalRule(const RuleStmt* stmt);
   void EvalCommand(const CommandStmt* stmt);
@@ -219,6 +222,16 @@ class Evaluator {
   bool IsEvaluatingCommand() const;
   void SetEvaluatingCommand(bool evaluating_command);
 
+  const vector<Symbol>& makefiles() const {
+    return makefiles_;
+  }
+
+  const vector<Symbol>& optional_makefiles() const {
+    return optional_makefiles_;
+  }
+
+  DepNode* current_dep_node = nullptr;
+
  private:
   Var* EvalRHS(Symbol lhs,
                Value* rhs,
@@ -226,7 +239,7 @@ class Evaluator {
                AssignOp op,
                bool is_override,
                bool* needs_assign);
-  void DoInclude(const string& fname);
+  void DoInclude(const string& fname, bool should_exist);
 
   void TraceVariableLookup(const char* operation, Symbol name, Var* var);
   Var* LookupVarGlobal(Symbol name);
@@ -285,6 +298,10 @@ class Evaluator {
   static SymbolSet used_undefined_vars_;
 
   bool is_evaluating_command_ = false;
+
+  bool second_expansion_ = false;
+
+  vector<Symbol> makefiles_, optional_makefiles_;
 };
 
 #endif  // EVAL_H_
diff --git a/src/exec.cc b/src/exec.cc
index 40f37dc..255f55f 100644
--- a/src/exec.cc
+++ b/src/exec.cc
@@ -49,7 +49,7 @@ class Executor {
     shellflag_ = ev->GetShellFlag();
   }
 
-  double ExecNode(const DepNode& n, const char* needed_by) {
+  double ExecNode(const DepNode& n, const char* needed_by, bool ignore_failure) {
     auto found = done_.find(n.output);
     if (found != done_.end()) {
       if (found->second == kProcessing) {
@@ -67,7 +67,7 @@ class Executor {
     LOG("ExecNode: %s for %s", n.output.c_str(),
         needed_by ? needed_by : "(null)");
 
-    if (!n.has_rule && output_ts == kNotExist && !n.is_phony) {
+    if (!n.has_rule && output_ts == kNotExist && !n.is_phony && !ignore_failure) {
       if (needed_by) {
         ERROR("*** No rule to make target '%s', needed by '%s'.",
               n.output.c_str(), needed_by);
@@ -81,13 +81,13 @@ class Executor {
       if (Exists(d.second->output.str())) {
         continue;
       }
-      double ts = ExecNode(*d.second, n.output.c_str());
+      double ts = ExecNode(*d.second, n.output.c_str(), ignore_failure);
       if (latest < ts)
         latest = ts;
     }
 
     for (auto const& d : n.deps) {
-      double ts = ExecNode(*d.second, n.output.c_str());
+      double ts = ExecNode(*d.second, n.output.c_str(), ignore_failure);
       if (latest < ts)
         latest = ts;
     }
@@ -122,6 +122,9 @@ class Executor {
       }
     }
 
+    struct timespec output_tv;
+    clock_gettime(CLOCK_REALTIME, &output_tv);
+    output_ts = output_tv.tv_sec + output_tv.tv_nsec * 0.001 * 0.001 * 0.001;
     done_[n.output] = output_ts;
     return output_ts;
   }
@@ -138,14 +141,10 @@ class Executor {
 
 }  // namespace
 
-void Exec(const vector<NamedDepNode>& roots, Evaluator* ev) {
+bool Exec(const vector<NamedDepNode>& roots, Evaluator* ev, bool ignore_failure) {
   Executor executor(ev);
   for (auto const& root : roots) {
-    executor.ExecNode(*root.second, nullptr);
-  }
-  if (executor.Count() == 0) {
-    for (auto const& root : roots) {
-      printf("kati: Nothing to be done for `%s'.\n", root.first.c_str());
-    }
+    executor.ExecNode(*root.second, nullptr, ignore_failure);
   }
+  return executor.Count() != 0;
 }
diff --git a/src/exec.h b/src/exec.h
index 34fda96..b96af78 100644
--- a/src/exec.h
+++ b/src/exec.h
@@ -21,6 +21,6 @@ using namespace std;
 #include "dep.h"
 class Evaluator;
 
-void Exec(const vector<NamedDepNode>& roots, Evaluator* ev);
+bool Exec(const vector<NamedDepNode>& roots, Evaluator* ev, bool ignore_failure = false);
 
 #endif  // EXEC_H_
diff --git a/src/flags.cc b/src/flags.cc
index e21a541..2f54051 100644
--- a/src/flags.cc
+++ b/src/flags.cc
@@ -70,6 +70,9 @@ void Flags::Parse(int argc, char** argv) {
       should_propagate = false;
     } else if (!strcmp(arg, "-c")) {
       is_syntax_check_only = true;
+    } else if (!strcmp(arg, "-C")) {
+      if (chdir(argv[++i]) != 0)
+        PERROR("chdir failed");
     } else if (!strcmp(arg, "-i")) {
       is_dry_run = true;
     } else if (!strcmp(arg, "-s")) {
@@ -185,8 +188,10 @@ void Flags::Parse(int argc, char** argv) {
       writable.push_back(writable_str);
     } else if (ParseCommandLineOptionWithArg("--default_pool", argv, &i,
                                              &default_pool)) {
+    } else if (!strncmp(arg, "--include-dir=", 14)) {
+      include_dirs.push_back(string(&arg[14]));
     } else if (arg[0] == '-') {
-      ERROR("Unknown flag: %s", arg);
+      WARN("Unknown flag: %s", arg);
     } else {
       if (strchr(arg, '=')) {
         cl_vars.push_back(arg);
diff --git a/src/flags.h b/src/flags.h
index 73410d5..57e7ba3 100644
--- a/src/flags.h
+++ b/src/flags.h
@@ -80,6 +80,7 @@ struct Flags {
   vector<Symbol> targets;
   vector<StringPiece> cl_vars;
   vector<string> writable;
+  vector<string> include_dirs;
 
   void Parse(int argc, char** argv);
 };
diff --git a/src/main.cc b/src/main.cc
index 417ec2c..146ae4c 100644
--- a/src/main.cc
+++ b/src/main.cc
@@ -44,6 +44,9 @@
 #include "timeutil.h"
 #include "var.h"
 
+char** argv_;
+char start_dir[1024];
+
 // We know that there are leaks in Kati. Turn off LeakSanitizer by default.
 extern "C" const char* __asan_default_options() {
   return "detect_leaks=0:allow_user_segv_handler=1";
@@ -101,10 +104,11 @@ static void ReadBootstrapMakefile(const vector<Symbol>& targets,
 static void SetVar(StringPiece l,
                    VarOrigin origin,
                    Frame* definition,
-                   Loc loc) {
+                   Loc loc,
+                   Symbol& lhs) {
   size_t found = l.find('=');
   CHECK(found != string::npos);
-  Symbol lhs = Intern(l.substr(0, found));
+  lhs = Intern(l.substr(0, found));
   StringPiece rhs = l.substr(found + 1);
   lhs.SetGlobalVar(new RecursiveVar(Value::NewLiteral(rhs.data()), origin,
                                     definition, loc, rhs.data()));
@@ -231,9 +235,13 @@ static int Run(const vector<Symbol>& targets,
       .SetGlobalVar(new SimpleVar(StringPrintf(" %s", g_flags.makefile),
                                   VarOrigin::FILE, ev.CurrentFrame(),
                                   ev.loc()));
+  vector<Symbol> envvars;
   for (char** p = environ; *p; p++) {
-    SetVar(*p, VarOrigin::ENVIRONMENT, nullptr, Loc());
+    Symbol lhs;
+    SetVar(*p, VarOrigin::ENVIRONMENT, nullptr, Loc(), lhs);
+    envvars.push_back(lhs);
   }
+  ev.ExportEnvVars(envvars);
   SegfaultHandler segfault(&ev);
 
   vector<Stmt*> bootstrap_asts;
@@ -282,6 +290,38 @@ static int Run(const vector<Symbol>& targets,
     ev.DumpIncludeJSON(std::string(g_flags.dump_include_graph));
   }
 
+  for (const auto& p : ev.exports()) {
+    const Symbol name = p.first;
+    if (p.second) {
+      Var* v = ev.LookupVar(name);
+      const string&& value = v->Eval(&ev);
+      LOG("setenv(%s, %s)", name.c_str(), value.c_str());
+      setenv(name.c_str(), value.c_str(), 1);
+    } else {
+      LOG("unsetenv(%s)", name.c_str());
+      unsetenv(name.c_str());
+    }
+  }
+
+  {
+    ScopedFrame frame(
+        ev.Enter(FrameType::PHASE, "*making makefiles*", Loc()));
+    ScopedTimeReporter tr("make makefiles time");
+    vector<NamedDepNode> nodes_makefiles, nodes_optional_makefiles;
+    MakeDep(&ev, ev.rules(), ev.rule_vars(), ev.makefiles(), &nodes_makefiles);
+    bool updated_makefiles = Exec(nodes_makefiles, &ev);
+    if (ev.optional_makefiles().size() != 0) {
+      MakeDep(&ev, ev.rules(), ev.rule_vars(), ev.optional_makefiles(), &nodes_optional_makefiles);
+      updated_makefiles |= Exec(nodes_optional_makefiles, &ev, true);
+    }
+    if (updated_makefiles) {
+      printf("\tStarting over.\n");
+      fflush(stdout);
+      chdir(start_dir);
+      execv(argv_[0], (char* const*)argv_);
+    }
+  }
+
   vector<NamedDepNode> nodes;
   {
     ScopedFrame frame(
@@ -302,19 +342,6 @@ static int Run(const vector<Symbol>& targets,
     return 0;
   }
 
-  for (const auto& p : ev.exports()) {
-    const Symbol name = p.first;
-    if (p.second) {
-      Var* v = ev.LookupVar(name);
-      const string&& value = v->Eval(&ev);
-      LOG("setenv(%s, %s)", name.c_str(), value.c_str());
-      setenv(name.c_str(), value.c_str(), 1);
-    } else {
-      LOG("unsetenv(%s)", name.c_str());
-      unsetenv(name.c_str());
-    }
-  }
-
   {
     ScopedFrame frame(ev.Enter(FrameType::PHASE, "*execution*", Loc()));
     ScopedTimeReporter tr("exec time");
@@ -353,6 +380,7 @@ static void HandleRealpath(int argc, char** argv) {
 }
 
 int main(int argc, char* argv[]) {
+  getcwd(start_dir, sizeof(start_dir));
   if (argc >= 2 && !strcmp(argv[1], "--realpath")) {
     HandleRealpath(argc - 2, argv + 2);
     return 0;
@@ -371,7 +399,8 @@ int main(int argc, char* argv[]) {
   }
   FindFirstMakefie();
   if (g_flags.makefile == NULL)
-    ERROR("*** No targets specified and no makefile found.");
+    g_flags.makefile = "";
+    //ERROR("*** No targets specified and no makefile found.");
   // This depends on command line flags.
   if (g_flags.use_find_emulator)
     InitFindEmulator();
diff --git a/src/ninja.cc b/src/ninja.cc
index ee4a87f..11d713f 100644
--- a/src/ninja.cc
+++ b/src/ninja.cc
@@ -414,7 +414,8 @@ class NinjaGenerator {
       while (isspace(*in))
         in++;
 
-      bool needs_subshell = (command_count > 1 || c.ignore_error);
+      bool needs_subshell =
+          (command_count > 1 || c.ignore_error) && !c.force_no_subshell;
 
       if (needs_subshell)
         *cmd_buf += '(';
diff --git a/src/rule.cc b/src/rule.cc
index 867a7e3..fc5340e 100644
--- a/src/rule.cc
+++ b/src/rule.cc
@@ -16,14 +16,17 @@
 
 #include "rule.h"
 
+#include "dep.h"
+#include "eval.h"
 #include "expr.h"
+#include "fileutil.h"
 #include "log.h"
 #include "parser.h"
 #include "stringprintf.h"
 #include "strutil.h"
 #include "symtab.h"
 
-Rule::Rule() : is_double_colon(false), is_suffix_rule(false), cmd_lineno(0) {}
+Rule::Rule() : is_double_colon(false), is_suffix_rule(false), parsed_inputs(false), cmd_lineno(0) {}
 
 void Rule::ParseInputs(const StringPiece& inputs_str) {
   bool is_order_only = false;
@@ -32,9 +35,31 @@ void Rule::ParseInputs(const StringPiece& inputs_str) {
       is_order_only = true;
       continue;
     }
-    Symbol input_sym = Intern(TrimLeadingCurdir(input));
-    (is_order_only ? order_only_inputs : inputs).push_back(input_sym);
+    vector<string> input_files;
+    if (!g_flags.generate_ninja) {
+      // TODO: Support in ninja mode
+      input_files = Glob(input.as_string().c_str());
+    }
+    if (input_files.size() == 0) {
+      input_files.push_back(input.as_string());
+    }
+    for (string input_file : input_files) {
+      Symbol input_sym = Intern(TrimLeadingCurdir(input_file));
+      (is_order_only ? order_only_inputs : inputs).push_back(input_sym);
+    }
   }
+  parsed_inputs = true;
+}
+
+void Rule::ParseInputs(Evaluator* ev) {
+  if (parsed_inputs) {
+    return;
+  }
+  if (second_expansion) {
+    Value* val = ParseExpr(&loc, prereq_string);
+    prereq_string = val->Eval(ev);
+  }
+  ParseInputs(prereq_string);
 }
 
 void Rule::ParsePrerequisites(const StringPiece& line,
@@ -46,19 +71,18 @@ void Rule::ParsePrerequisites(const StringPiece& line,
   //    target-prerequisites : prereq-patterns [ ; command ]
   // First, separate command. At this point separator_pos should point to ';'
   // unless null.
-  StringPiece prereq_string = line;
+  prereq_string = string(line.data(), line.size());
   if (separator_pos != string::npos &&
       rule_stmt->sep != RuleStmt::SEP_SEMICOLON) {
     CHECK(line[separator_pos] == ';');
     // TODO: Maybe better to avoid Intern here?
     cmds.push_back(Value::NewLiteral(
         Intern(TrimLeftSpace(line.substr(separator_pos + 1))).str()));
-    prereq_string = line.substr(0, separator_pos);
+    prereq_string = prereq_string.substr(0, separator_pos);
   }
 
   if ((separator_pos = prereq_string.find(':')) == string::npos) {
     // Simple prerequisites
-    ParseInputs(prereq_string);
     return;
   }
 
@@ -73,8 +97,7 @@ void Rule::ParsePrerequisites(const StringPiece& line,
     return;
   }
 
-  StringPiece target_prereq = prereq_string.substr(0, separator_pos);
-  StringPiece prereq_patterns = prereq_string.substr(separator_pos + 1);
+  string target_prereq = prereq_string.substr(0, separator_pos);
 
   for (StringPiece target_pattern : WordScanner(target_prereq)) {
     target_pattern = TrimLeadingCurdir(target_pattern);
@@ -87,6 +110,8 @@ void Rule::ParsePrerequisites(const StringPiece& line,
     output_patterns.push_back(Intern(target_pattern));
   }
 
+  prereq_string = prereq_string.substr(separator_pos + 1);
+
   if (output_patterns.empty()) {
     ERROR_LOC(loc, "*** missing target pattern.");
   }
@@ -96,7 +121,15 @@ void Rule::ParsePrerequisites(const StringPiece& line,
   if (!IsPatternRule(output_patterns[0].str())) {
     ERROR_LOC(loc, "*** target pattern contains no '%%'.");
   }
-  ParseInputs(prereq_patterns);
+}
+
+shared_ptr<Rule> Rule::ApplyPattern(Pattern pat, Symbol output) const {
+  shared_ptr<Rule> new_rule = make_shared<Rule>(*this);
+  string buf;
+  pat.AppendSubst(output.str(), prereq_string, &buf);
+  new_rule->prereq_string = buf;
+  new_rule->parsed_inputs = false;
+  return new_rule;
 }
 
 string Rule::DebugString() const {
diff --git a/src/rule.h b/src/rule.h
index 237eb02..46110e2 100644
--- a/src/rule.h
+++ b/src/rule.h
@@ -16,13 +16,16 @@
 #define RULE_H_
 
 #include <functional>
+#include <memory>
 #include <string>
 #include <vector>
 
+#include "eval.h"
 #include "loc.h"
 #include "log.h"
 #include "stmt.h"
 #include "string_piece.h"
+#include "strutil.h"
 #include "symtab.h"
 
 using namespace std;
@@ -37,8 +40,6 @@ class Rule {
 
   string DebugString() const;
 
-  void ParseInputs(const StringPiece& inputs_string);
-
   void ParsePrerequisites(const StringPiece& line,
                           size_t pos,
                           const RuleStmt* rule_stmt);
@@ -47,6 +48,9 @@ class Rule {
     return target_string.find('%') != string::npos;
   }
 
+  void ParseInputs(Evaluator* ev);
+  shared_ptr<Rule> ApplyPattern(Pattern pat, Symbol output) const;
+
   vector<Symbol> outputs;
   vector<Symbol> inputs;
   vector<Symbol> order_only_inputs;
@@ -54,12 +58,16 @@ class Rule {
   vector<Symbol> validations;
   bool is_double_colon;
   bool is_suffix_rule;
+  bool second_expansion;
+  bool parsed_inputs;
   vector<Value*> cmds;
   Loc loc;
   int cmd_lineno;
+  string prereq_string;
 
  private:
   void Error(const string& msg) { ERROR_LOC(loc, "%s", msg.c_str()); }
+  void ParseInputs(const StringPiece& inputs_string);
 };
 
 #endif  // RULE_H_
diff --git a/src/string_piece.cc b/src/string_piece.cc
index 32a7be0..3eeaa73 100644
--- a/src/string_piece.cc
+++ b/src/string_piece.cc
@@ -36,9 +36,9 @@ bool operator==(const StringPiece& x, const StringPiece& y) {
   size_t len = x.size();
   if (len >= sizeof(uint64_t)) {
     len -= sizeof(uint64_t);
-    uint64_t xt = *reinterpret_cast<const uint64_t*>(x.data() + len);
-    uint64_t yt = *reinterpret_cast<const uint64_t*>(y.data() + len);
-    if (xt != yt)
+    const char* xptr = reinterpret_cast<const char*>(x.data() + len);
+    const char* yptr = reinterpret_cast<const char*>(y.data() + len);
+    if (StringPiece::wordmemcmp(xptr, yptr, 8))
       return false;
   }
   return StringPiece::wordmemcmp(x.data(), y.data(), len) == 0;
diff --git a/src/strutil.cc b/src/strutil.cc
index 8c4bdc0..c403ae3 100644
--- a/src/strutil.cc
+++ b/src/strutil.cc
@@ -178,17 +178,16 @@ void Pattern::AppendSubst(StringPiece str,
   }
 
   if (MatchImpl(str)) {
-    size_t subst_percent_index = subst.find('%');
-    if (subst_percent_index == string::npos) {
-      AppendString(subst, out);
-      return;
-    } else {
-      AppendString(subst.substr(0, subst_percent_index), out);
-      AppendString(str.substr(percent_index_, str.size() - pat_.size() + 1),
-                   out);
-      AppendString(subst.substr(subst_percent_index + 1), out);
-      return;
+    string subst_str = subst.as_string();
+    string stem = str.substr(percent_index_, str.size() - pat_.size() + 1).as_string();
+
+    size_t subst_percent_index = string::npos;
+    while ((subst_percent_index = subst_str.rfind('%', subst_percent_index - 1)) != string::npos) {
+      subst_str.replace(subst_percent_index, 1, stem);
     }
+
+    AppendString(subst_str, out);
+    return;
   }
   AppendString(str, out);
 }
@@ -431,8 +430,9 @@ StringPiece TrimLeadingCurdir(StringPiece s) {
 }
 
 void FormatForCommandSubstitution(string* s) {
-  while ((*s)[s->size() - 1] == '\n')
+  while (s->size() > 0 && (*s)[s->size() - 1] == '\n') {
     s->pop_back();
+  }
   for (size_t i = 0; i < s->size(); i++) {
     if ((*s)[i] == '\n')
       (*s)[i] = ' ';
diff --git a/testcase/include_dir.sh b/testcase/include_dir.sh
new file mode 100755
index 0000000..a7491d7
--- /dev/null
+++ b/testcase/include_dir.sh
@@ -0,0 +1,13 @@
+set -e
+
+mk="$@"
+
+cat <<EOF > Makefile
+test: test2
+	echo PASS
+include myfile.mk
+EOF
+
+mkdir -p test_dir
+echo -e "test2:\n\techo \$@" > test_dir/myfile.mk
+${mk} --include-dir=test_dir 2> /dev/null
diff --git a/testcase/question.sh b/testcase/question.sh
new file mode 100755
index 0000000..0d3c7c4
--- /dev/null
+++ b/testcase/question.sh
@@ -0,0 +1,45 @@
+#!/bin/sh
+#
+# Copyright 2022 Google Inc. All rights reserved
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http:#www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+set -e
+
+mk="$@"
+
+cat <<EOF > Makefile
+
+all: d
+
+a:
+	echo a > a
+
+b:
+	echo b > b
+
+c:
+	echo c > c
+
+d: a b c
+	echo \$? > d
+
+EOF
+
+${mk}
+cat d
+sleep 0.1
+touch b
+${mk}
+cat d
+
